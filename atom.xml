<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>象帝浮华生</title>
  
  <subtitle>大道至简</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ahianzhang.com/"/>
  <updated>2020-10-21T04:05:09.593Z</updated>
  <id>https://ahianzhang.com/</id>
  
  <author>
    <name>Ahian Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 cucumber 进行行为驱动开发（BDD）</title>
    <link href="https://ahianzhang.com/2020/10/20/spring-boot-cucumber/"/>
    <id>https://ahianzhang.com/2020/10/20/spring-boot-cucumber/</id>
    <published>2020-10-20T05:56:39.000Z</published>
    <updated>2020-10-21T04:05:09.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>保证软件质量的方式多种多样，根据测试金字塔上所描绘的，单元测试是最有效的，但是在公司内部实践的时候却遇到了一些问题，比如赶进度来不及写单元测试、改了代码逻辑单元测试也需要跟着变、验收时同样会有很多 bug，总结下来大概有几个原因：</p><ul><li>需求分析时有很多细节没有考虑到（这个不可避免）</li><li>测试用例覆盖的场景不全</li><li>分层架构需要对每一层都进行测试，会占用大量时间</li></ul><p>还有一个原因是<strong>公司技术环境</strong>，我司是业务驱动的，主营业务在线下，最有价值是业务而非技术。</p><p>综合多方面的原因，决定尝试 BDD 的测试方式，这样做的好处可以分为以下几点：</p><ul><li>活文档，好的用例能够体现业务的整个面貌</li><li>将关注点放到更有价值的业务上来，而非技术</li><li>对于目前团队现状，BDD 的投入产出比要比单元测试更好</li></ul><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>以<strong>用户登录</strong>的用户故事举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">作为一名供应商，我希望在输入用户名：”admin“，密码：“admin” 后能够进到系统首页，然后能够进行数据操作</span><br><span class="line"></span><br><span class="line">验收标准：</span><br><span class="line"> 场景1：用户名密码正确</span><br><span class="line">  Given：用户名：admin，密码：admin</span><br><span class="line">  When：我在登录页上输入用户名 admin 和密码 admin</span><br><span class="line">  Then：我将进入到系统首页</span><br><span class="line">  </span><br><span class="line"> 场景2：用户名或密码不正确</span><br><span class="line"> Given：用户名：admin，密码：admin</span><br><span class="line"> When：我在登录页上输入用户名 admin 和密码 admin123</span><br><span class="line"> Then：我被告知 “用户名或者密码错误”</span><br><span class="line"> AND：此时我还是未登录状态</span><br></pre></td></tr></table></figure><p>注意：对于用户故事验收标准这部分应该以用户行为为主，避免UI操作的字段出现，比如“我点击了提交按钮”，这样是不推荐的。</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.cucumber<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cucumber-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;cucumber.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.cucumber<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cucumber-junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;cucumber.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.cucumber<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cucumber-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;cucumber.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="添加-feature-文件"><a href="#添加-feature-文件" class="headerlink" title="添加 feature 文件"></a>添加 feature 文件</h2><p>在 /src/test/resource 文件夹下新建 feature 文件夹，并在此文件夹中创建 login.feature 文件。</p><p>添加一个场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#language: zh-CN</span><br><span class="line">功能：供应商登录</span><br><span class="line">   场景大纲: 用户名密码正确</span><br><span class="line">     假设已注册的供应商用户名密码 admin admin</span><br><span class="line">     当供应商输入用户名密码&lt;username&gt;&lt;password&gt;</span><br><span class="line">     那么能够进入到系统首页</span><br><span class="line">     例子:</span><br><span class="line">     |username|password|</span><br><span class="line">     |admin   |admin   |</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>#language: zh-CN 指定使用的语言</li><li>功能：对应 user story 的标题</li><li>场景：对应功能的其中一种情况</li><li>假设、当、那么：cucumber 指定的中文 DSL，对于 Given、When、Then</li><li>对于要使用变量的地方使用 <code>&lt;</code> <code>&gt;</code> 标注出来并在下面的例子中列出数据内容</li></ul><p>注意：feature 中的标点符号<strong>全部为英文标点</strong></p><h2 id="右键运行"><a href="#右键运行" class="headerlink" title="右键运行"></a>右键运行</h2><p>此时我们还未创建任何业务代码，但是还是会有高亮展示</p><p><img src="https://ahian-blog.oss-cn-beijing.aliyuncs.com/images/2020-10-20-095457.png" alt="image-20201020175455431"></p><p>此时，我们右键点击会有下面的按钮</p><p><img src="https://ahian-blog.oss-cn-beijing.aliyuncs.com/images/2020-10-20-095658.png" alt="image-20201020175654194"></p><p>点击运行</p><p><img src="https://ahian-blog.oss-cn-beijing.aliyuncs.com/images/2020-10-20-095754.png" alt="image-20201020175752514"></p><p>因为我们还没有编写代码，所以此时测试一定会报错，那么接下来需要做的是写代码让这段测试通过</p><h2 id="步骤定义"><a href="#步骤定义" class="headerlink" title="步骤定义"></a>步骤定义</h2><p>在  /src/test/java 下新建一个 login 的文件夹，并新建 <strong>LoginStepDef</strong> java 文件。我们的测试逻辑将在这个文件中完成。本次仅对密码正确的情况做演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CucumberContextConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginStepDef</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  Account account;</span><br><span class="line">        @假设(<span class="string">"^已注册的供应商用户名密码 admin admin$"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">            account = <span class="keyword">new</span> Account(<span class="string">"admin"</span>,<span class="string">"admin"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @当(<span class="string">"^供应商输入用户名密码(\\S*)(\\S*)$"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">when_input_account_info</span><span class="params">(String username,String password)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (account.valid(username,password))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       @那么(<span class="string">"^能够进入到系统首页$"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get_into_index</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li><p><code>@CucumberContextConfiguration</code> cucumber 提供的 Spring 集成注解</p></li><li><p><code>@假设(&quot;^已注册的供应商用户名密码 admin admin$&quot;)</code>@假设是中文的注解（中英文对照表请参见文末表格），与 feature 文件相对应。<code>^</code> <code>$</code>  和 shell 功能类似，代表一行的开头和结尾，固定格式。</p></li><li><p>对于需要传递参数的方法需要使用正则表达式进行占位</p></li></ol><ul><li><p>整型  (\d+)</p></li><li><p>字符串 (\S*)</p></li><li><p>布尔值 (true|false)</p></li><li><p>列表 使用 DataTable 举例：</p><blockquote><p>Given the following animals:</p><pre><code>| cow   || horse || sheep |</code></pre><p>定义时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Given</span>(<span class="string">"the following animals:"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">the_following_animals</span><span class="params">(List&lt;String&gt; animals)</span> </span>&#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="配置-Junit-引导"><a href="#配置-Junit-引导" class="headerlink" title="配置 Junit 引导"></a>配置 Junit 引导</h2><p>在 /src/test/java/login 中创建名为 LoginIntegerationTest 的 java 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(Cucumber<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">CucumberOptions</span>(<span class="title">features</span> </span>= <span class="string">"classpath:features/login"</span>,</span><br><span class="line">        plugin = &#123;<span class="string">"pretty"</span>, <span class="string">"html:target/cucumber/login.html"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginIntegrationTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li><code>@CucumberOptions</code>  cucumber 的配置注解</li><li><code>features</code> 指定 feature 文件的路径</li><li><code>plugin</code> 将测试结果以 html 的格式输出到指定目录</li></ol><h2 id="再次运行"><a href="#再次运行" class="headerlink" title="再次运行"></a>再次运行</h2><p><img src="https://ahian-blog.oss-cn-beijing.aliyuncs.com/images/2020-10-21-035140.png" alt="image-20201021115138478"></p><h2 id="查看测试报告"><a href="#查看测试报告" class="headerlink" title="查看测试报告"></a>查看测试报告</h2><p>根据配置的目录，找到对应的 html 文件</p><p><img src="https://ahian-blog.oss-cn-beijing.aliyuncs.com/images/2020-10-21-035250.png" alt="image-20201021115248832"></p><h2 id="Jenkins-集成"><a href="#Jenkins-集成" class="headerlink" title="Jenkins 集成"></a>Jenkins 集成</h2><p>Github 中有开源的 Jenkins Plugin： <a href="https://github.com/jenkinsci/cucumber-reports-plugin" target="_blank" rel="noopener">Publish pretty cucumber-jvm reports on Jenkins</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如何选择合适的测试手段，需要结合企业研发团队的现状和经营模式做选型，TDD 虽然能提升质量，但并不适用所有的企业。</p><p>本文对 cucumber 做了一个基础的演示，对于复杂的环境，推荐结合 <a href="https://rest-assured.io/" target="_blank" rel="noopener">Rest Assured</a> 对 API 做测试。</p><p>想要了解更多可以查看文末参考资料。</p><h1 id="附表"><a href="#附表" class="headerlink" title="附表"></a>附表</h1><h2 id="中英文关键字的对照表"><a href="#中英文关键字的对照表" class="headerlink" title="中英文关键字的对照表"></a>中英文关键字的对照表</h2><table><thead><tr><th>英文关键字</th><th>中文关键字</th></tr></thead><tbody><tr><td>feature</td><td>“功能”</td></tr><tr><td>background</td><td>“背景”</td></tr><tr><td>scenario</td><td>“场景”, “剧本”</td></tr><tr><td>scenario_outline</td><td>“场景大纲”, “剧本大纲”</td></tr><tr><td>examples</td><td>“例子”</td></tr><tr><td>given</td><td>“* “, “假如”, “假设”, “假定”</td></tr><tr><td>when</td><td>“* “, “当”</td></tr><tr><td>then</td><td>“* “, “那么”</td></tr><tr><td>and</td><td>“* “, “而且”, “并且”, “同时”</td></tr><tr><td>but</td><td>“* “, “但是”</td></tr><tr><td>given (code)</td><td>“假如”, “假设”, “假定”</td></tr><tr><td>when (code)</td><td>“当”</td></tr><tr><td>then (code)</td><td>“那么”</td></tr><tr><td>and (code)</td><td>“而且”, “并且”, “同时”</td></tr><tr><td>but (code)</td><td>“但是”</td></tr></tbody></table><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://vitzhou.gitbooks.io/java-test-learning/content/cucumber/practice/chinese.html" target="_blank" rel="noopener">https://vitzhou.gitbooks.io/java-test-learning/content/cucumber/practice/chinese.html</a></p><p><a href="https://vitzhou.gitbooks.io/java-test-learning/content/cucumber/practice/pass_parameters.html" target="_blank" rel="noopener">https://vitzhou.gitbooks.io/java-test-learning/content/cucumber/practice/pass_parameters.html</a></p><p><a href="https://developer.ibm.com/zh/articles/j-lo-cucumber01/" target="_blank" rel="noopener">https://developer.ibm.com/zh/articles/j-lo-cucumber01/</a></p><h1 id="相关书籍"><a href="#相关书籍" class="headerlink" title="相关书籍"></a>相关书籍</h1><p><a href="https://book.douban.com/subject/24843412/" target="_blank" rel="noopener">Cucumber：行为驱动开发指南</a></p>]]></content>
    
    <summary type="html">
    
      cucumber 是 BDD 的一款很老牌的框架，使用 Ruby 进行开发，并对 Java 做了兼容
    
    </summary>
    
    
      <category term="总结" scheme="https://ahianzhang.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Cucumber" scheme="https://ahianzhang.com/tags/Cucumber/"/>
    
      <category term="BDD" scheme="https://ahianzhang.com/tags/BDD/"/>
    
  </entry>
  
  <entry>
    <title>微服务应用集成 SpringCloud 步骤</title>
    <link href="https://ahianzhang.com/2020/10/13/spring-cloud-intergration/"/>
    <id>https://ahianzhang.com/2020/10/13/spring-cloud-intergration/</id>
    <published>2020-10-13T07:14:02.000Z</published>
    <updated>2020-10-14T01:57:28.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>微服务开发模式能够将复杂的业务拆分成独立的更细粒度服务，一定程度上降低了业务复杂度，但是随之而来的是如何保证各个服务的可靠性和稳定性，SpringCloud 出现的目的是为了解决这些在服务拆分后会遇到的通用问题。配置中心能让同一服务多实例间无需重启快速更新配置、注册中心能对应用节点动态管理、网关是为了对 API 做统一的处理等。</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p><strong>默认有已经部署好了 Nacos Server。</strong></p><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;latest.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建 bootstrap.yml 并添加下面的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">discovery:</span></span><br><span class="line">  <span class="attr">group:</span> <span class="string">infra</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">7925f1c5-3291-4c0b-b4c4-920a532958f1</span></span><br><span class="line">  <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.110</span><span class="number">.65</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure><h2 id="服务配置"><a href="#服务配置" class="headerlink" title="服务配置"></a>服务配置</h2><p><strong>默认有已经部署好了 Nacos Server。</strong></p><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;latest.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 bootstrap.yml 中添加下面的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nacos:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">INFRA</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">7925f1c5-3291-4c0b-b4c4-920a532958f1</span></span><br><span class="line">    <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.110</span><span class="number">.65</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure><p>配置完成后 bootstarp.yml 的样例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">auth-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">INFRA</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">7925f1c5-3291-4c0b-b4c4-920a532958f1</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.110</span><span class="number">.65</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">infra</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">7925f1c5-3291-4c0b-b4c4-920a532958f1</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.110</span><span class="number">.65</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure><h2 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h2><p><strong>默认 API 网关以部署好并与 nacos 做好了集成</strong>，<strong>对外提供动态路由配置、认证、限流等功能。</strong>以 Spring Cloud Gateway 为例。</p><p>在 API Gateway 的配置中心中添加路由配置，示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>:<span class="string">"oauth-test"</span>, </span><br><span class="line">    <span class="attr">"predicates"</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>:<span class="string">"Path"</span>,</span><br><span class="line">            <span class="attr">"args"</span>:&#123;</span><br><span class="line">                <span class="attr">"pattern"</span>:<span class="string">"/baidu/**"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"uri"</span>:<span class="string">"http://baidu.com/"</span>,</span><br><span class="line">    <span class="attr">"filters"</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>:<span class="string">"StripPrefix"</span>,</span><br><span class="line">            <span class="attr">"args"</span>:&#123;</span><br><span class="line">                <span class="attr">"parts"</span>:<span class="string">"1"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>:<span class="string">"Auth"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>id：路由的唯一标识</li><li>predicates：前置判断，符合相应的配置才能交给后面的过滤器</li><li>uri：最终调整的地址</li><li>filters：过滤器集合，这里配了 StripPrefix（跳转后会抹掉 /baidu 这个路径），Auth（开启认证过滤）</li></ul><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>计划中，Prometheus + Grafana </p><h2 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h2><p>计划中，Spring Cloud Sle    uth + ZipKin 或者 CAT</p><h2 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h2><p>计划中，Spring Cloud Alibaba Sentinel</p><h2 id="分布式事务（可选）"><a href="#分布式事务（可选）" class="headerlink" title="分布式事务（可选）"></a>分布式事务（可选）</h2><p>目前在 Spring 官方文档中并未将事务纳入 Cloud 中，但是在实际开发中如果需要也可使用。</p><p>计划中，Spring Cloud Alibaba Seata</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>SpringCloud 设计初衷是为了解决微服务治理相关的问题，提供一套开箱即用的组件，让开发者将重点放到服务拆分和设计上。上面介绍的几个组件都是微服务治理体系中必不可少的内容，所以如果想从单体应用转到微服务一定要搭建相应的治理平台，才能保证服务的可靠性和稳定性。</p>]]></content>
    
    <summary type="html">
    
      一个微服务应用如何集成和使用 SpringCloud 组件
    
    </summary>
    
    
      <category term="总结" scheme="https://ahianzhang.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="SpringCloud" scheme="https://ahianzhang.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>电商搜索数据同步方案</title>
    <link href="https://ahianzhang.com/2020/10/10/change-data-capture/"/>
    <id>https://ahianzhang.com/2020/10/10/change-data-capture/</id>
    <published>2020-10-10T02:36:07.000Z</published>
    <updated>2020-10-12T02:09:25.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>搜索系统主要分为两个部分一个是在线服务、一个是离线服务，在线服务是指排序、打分等靠近用户侧的部分，离线服务负责这篇文章属于离线部分范畴，本篇文章只是提供一个基础的思路，实际使用还需要适当调整和拓展。无论哪种方式都应该保证全量高吞吐、增量低延时的这个原则。</p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h2 id="定时任务主动拉取更新"><a href="#定时任务主动拉取更新" class="headerlink" title="定时任务主动拉取更新"></a>定时任务主动拉取更新</h2><p>这个方案是最简单最直观的实现方式，通过 SQL 关联查询，全量更新和增量更新通过定时任务去触发。</p><p>优点：适合快速开发，且与业务系统代码解耦。</p><p>缺点：对数据库压力较大；如果跨数据库关联会增加复杂度；实时性低。</p><p><img src="https://ahian-blog.oss-cn-beijing.aliyuncs.com/images/2020-10-10-070844.png" alt="image-20201010150842337"></p><h2 id="订阅队列异步更新"><a href="#订阅队列异步更新" class="headerlink" title="订阅队列异步更新"></a>订阅队列异步更新</h2><p>异步更新常出现在事件驱动的架构中，扣件库存事件、价格变更事件、商品上下架事件等，这种方案需要分布式队列的支持。</p><p>优点：实时性高，对数据库压力小。</p><p>缺点：需要保证消息的消息队列的可靠性、顺序消费、重复消费等；对非事件驱动架构的业务代码有入侵性。</p><p><img src="https://ahian-blog.oss-cn-beijing.aliyuncs.com/images/2020-10-10-090117.png" alt="image-20201010170115099"></p><p>说明：上图中 product id 是从消息队列拿到变更的商品 id，然后根据 id 去反查业务库中的数据；data 是通过 SQL 拿到的结构化数据，这个步骤在全量更新时也会用到。</p><h2 id="使用-Binlog-工具更新"><a href="#使用-Binlog-工具更新" class="headerlink" title="使用 Binlog 工具更新"></a>使用 Binlog 工具更新</h2><p>Binlog 是 MysQL 中最重要的日志，它记录了 DDL 和 DML 操作，在 MySQL 主从复制或者数据恢复时会使用到，当然也可以用在同步数据上，由于 Binlog 是二进制文件无法直接使用，市面上有很多成熟的<a href="https://github.com/wushujames/mysql-cdc-projects/wiki" target="_blank" rel="noopener">解析工具</a>，目前 Canal 是比较适合国内的业务场景。</p><p>优点：与业务系统解耦</p><p>缺点：需要引入消息队列和 Binlog 解析中间件，增加了架构的复杂性</p><p><img src="https://ahian-blog.oss-cn-beijing.aliyuncs.com/images/2020-10-12-014017.png" alt="image-20201012094015040"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面介绍了搜索的三种数据同步方案，使用者需要根据实际的业务场景进行选择和拓展。</p><p>监听 Binlog 这种设计在搜索系统中的使用场景仅限于数据的增量同步，这样能够做到准实时更新，而对于同步更新则需要进行周期性的通过 SQL 或者接口进行更新。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://insights.thoughtworks.cn/application-of-cdc-in-microservices/" target="_blank" rel="noopener">https://insights.thoughtworks.cn/application-of-cdc-in-microservices/</a></p><p><a href="https://github.com/wushujames/mysql-cdc-projects/wiki" target="_blank" rel="noopener">https://github.com/wushujames/mysql-cdc-projects/wiki</a></p><p><a href="https://www.cnblogs.com/binghe001/p/13415987.html" target="_blank" rel="noopener">https://www.cnblogs.com/binghe001/p/13415987.html</a></p>]]></content>
    
    <summary type="html">
    
      搜索系统的元数据管理是最基础的部分，本文会讲到如何将变更的业务数据同步到搜索中
    
    </summary>
    
    
      <category term="搜索" scheme="https://ahianzhang.com/categories/%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="方案" scheme="https://ahianzhang.com/tags/%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>通过一道数值转换题重温计算机补码</title>
    <link href="https://ahianzhang.com/2020/07/02/summary14/"/>
    <id>https://ahianzhang.com/2020/07/02/summary14/</id>
    <published>2020-07-02T02:56:53.000Z</published>
    <updated>2020-10-10T02:41:44.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>昨天同事和我聊了他偶然间看到的一道面试题，引出了后面的深入分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.valueOf((<span class="keyword">char</span>)-<span class="number">1</span>)); <span class="comment">//output: 65535</span></span><br></pre></td></tr></table></figure><p>为什么输出是 65535 而不是 -1 呢？</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>先回顾一下计算机相关的知识点：</p><p>原码(True form)</p><blockquote><p>原码是指一个<a href="https://zh.wikipedia.org/wiki/二进制" target="_blank" rel="noopener">二进制</a>数左边加上符号位后所得到的码，且当二进制数大于0时，符号位为0；二进制数小于0时，符号位为1；二进制数等于0时，符号位可以为0或1(+0/-0)。 –维基百科</p></blockquote><p>原码根据符号位能很直观的看出是正数还是负数，但是对于计算机运算来说却不是那么好用了，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 求解: 1 + (-1) </span></span><br><span class="line">---</span><br><span class="line">站在人类的视角会立马得出 1 + (-1) = 0 的结论</span><br><span class="line">---</span><br><span class="line">而计算机的角度(假设长度是8-bit)：</span><br><span class="line">转换成二进制并相加：</span><br><span class="line">  00000001</span><br><span class="line">+ 10000001</span><br><span class="line"> ----------</span><br><span class="line">  10000010</span><br><span class="line"> </span><br><span class="line">这个结果是：-2，与正确值不符</span><br></pre></td></tr></table></figure><p>所以如果有负数使用了原码运算，那还得把符号位撇开，这就增加了使用成本，为了解决这个问题就出现了反码。</p><hr><p>反码(ones’ complement)，也叫<strong>一的补码</strong></p><blockquote><p>将<a href="https://zh.wikipedia.org/wiki/二进制" target="_blank" rel="noopener">二进制</a>数每个数字反转，得到的数即为原二进制的<strong>一的补码</strong>（英语：ones’ complement）。若某一位为0，则使其变为1，反之亦然。</p><ul><li>一的补码以有符号比特的二进制数定义。</li><li>一的补码是有符号比特的二进制数。</li><li>正数和0的一的补码就是该数字本身。–维基百科</li></ul></blockquote><p>反码能解决负数运算的问题吗，可以，但是又会出现<strong>负零</strong>和<strong>循环进位</strong>的问题。举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 求解  1 + (-1)</span></span><br><span class="line">---</span><br><span class="line">转换成二进制并取反相加</span><br><span class="line">  00000001 (正数的反码是它本身)</span><br><span class="line">+ 11111110 (符号位不变其余取反)</span><br><span class="line">------------</span><br><span class="line">  11111111 </span><br><span class="line">转换成原码为：100000000 = -0</span><br></pre></td></tr></table></figure><p>对于 0 来说正负并没有意义, 而且还会有反码 0000 0000 和 1111 1111 这两种 0 的表现形式，在使用反码运算时判断是否为 0 还需要考虑这两种情况，为了解决这个问题就又出现了补码。</p><hr><p>补码(2’s complement)</p><blockquote><p>正数和0的补码就是该数字本身。负数的补码则是将其对应正数按位取反再加1。</p><p>补码系统的最大优点是可以在<a href="https://zh.wikipedia.org/wiki/加法" target="_blank" rel="noopener">加法</a>或<a href="https://zh.wikipedia.org/wiki/減法" target="_blank" rel="noopener">减法</a>处理中，不需因为数字的正负而使用不同的计算方式。只要一种加法电路就可以处理各种有号数加法，而且减法可以用一个数加上另一个数的补码来表示，因此只要有加法电路及补码电路即可完成各种有号数加法及减法，在电路设计上相当方便。</p><p>另外，补码系统的0就只有一个表示方式，这和<a href="https://zh.wikipedia.org/wiki/一補數" target="_blank" rel="noopener">反码</a>系统不同（在反码系统中，0有二种表示方式），因此在判断数字是否为0时，只要比较一次即可  –维基百科</p></blockquote><p>补码有一个原则：<strong>数字a的补码为 -a</strong>，举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> a = -5,那么 a 的补码为 5</span></span><br><span class="line">10000101  # -5 的原码</span><br><span class="line">11111010  # -5 的反码</span><br><span class="line">11111011  # -5 的补码</span><br></pre></td></tr></table></figure><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><p>上面的问题可以拆分成下面的代码便于分析</p><p><img src="https://ahian-blog.oss-cn-beijing.aliyuncs.com/images/2020-07-09-075147.png" alt="image-20200707094407456"></p><p>int(32-bit) 转 char(16-bit) 会失去精度 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1000 0000 0000 0000 0000 0000 0000 0001   #int -1 的原码</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1111   #int -1 的补码(内存中的数值用补码表示 0Xffffffff) </span><br><span class="line">                    1111 1111 1111 1111   #char 只保留 16 位；10进制为 65535</span><br><span class="line">0000 0000 0000 0000 1111 1111 1111 1111   #再转换成 int 执行零扩展；10进制同样为 65535</span><br></pre></td></tr></table></figure><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>溢出</p><p>符号扩展与零扩展</p><p>循环进位</p>]]></content>
    
    <summary type="html">
    
      涉及到源码、反码、补码
    
    </summary>
    
    
      <category term="总结" scheme="https://ahianzhang.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="补码" scheme="https://ahianzhang.com/tags/%E8%A1%A5%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>macOS 系统推荐的一些软件</title>
    <link href="https://ahianzhang.com/2020/06/25/macos-tools/"/>
    <id>https://ahianzhang.com/2020/06/25/macos-tools/</id>
    <published>2020-06-25T11:03:45.000Z</published>
    <updated>2020-07-14T07:05:13.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h1><ul><li>词典：mac 自带的，点按翻译</li><li>沙拉查词： chrome 上画线翻译</li><li>Alfred workflow + 有道翻译：支持查询单词并且回车键入当前位置</li></ul><h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><ul><li>IntelliJ IDEA：Java 工程利器</li><li>VSCode：写 React 和 Angular</li></ul><h1 id="SSH-工具"><a href="#SSH-工具" class="headerlink" title="SSH 工具"></a>SSH 工具</h1><ul><li>electerm：最新发现的（2020-7-14），挺好用</li></ul><h1 id="壁纸"><a href="#壁纸" class="headerlink" title="壁纸"></a>壁纸</h1><ul><li>pap.er： 免费的，还不错</li></ul><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><ul><li>印象笔记</li></ul><h1 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h1><ul><li>Spotify：大陆上的歌很少，都是有版权的，淘宝上买了包年会员</li></ul><h1 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h1><ul><li>Alfred：流控</li><li>Manico：快捷启动</li><li>Vimium：Chrome 的 vim 快捷键</li><li>Rectangle：窗口分屏</li></ul><h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><ul><li>Zsh</li><li>NutShell</li><li>Tldr</li></ul><h1 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h1><ul><li>Keka：官网下载是免费的</li></ul><h1 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h1><ul><li>Typora：MarkDown 语法，界面简单大方</li><li>iPic: 图片上传工具，付费，搭配阿里云 OSS 很棒</li></ul><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><ul><li>xmid zen ，现在改名叫 xmind 2020</li></ul><h1 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h1><ul><li>Draw.io</li><li>Sketch</li></ul><h1 id="办公"><a href="#办公" class="headerlink" title="办公"></a>办公</h1><ul><li>微信</li><li>钉钉</li><li>WPS</li><li>Foxmail</li></ul>]]></content>
    
    <summary type="html">
    
      在 Mac 下尝试过很多的软件，下面列出的都是我个人感觉不错的软件
    
    </summary>
    
    
      <category term="总结" scheme="https://ahianzhang.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="macOS" scheme="https://ahianzhang.com/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>DevOps 实施规划（持续更新）</title>
    <link href="https://ahianzhang.com/2020/05/08/devops-01/"/>
    <id>https://ahianzhang.com/2020/05/08/devops-01/</id>
    <published>2020-05-08T01:12:16.000Z</published>
    <updated>2020-05-19T11:47:46.243Z</updated>
    
    <content type="html"><![CDATA[<p>下面是我在日常工作中碰到的现状，相信大多数中小企业也会有类似情况</p><ul><li>需求不明确</li><li>流程不够自动化</li><li>没有写单元测试的意识</li><li>上班摸鱼</li><li>不愿接受新思想</li><li>工作总是被打断</li><li>服务器资源利用率不高</li></ul><p>出现问题的原因有领导的问题，也有团队成员的问题。但问题已经出现，此时不应该是无休止的抱怨，而是寻找解决问题办法。我们公司为了解决这样的问题，综合考虑了现状，实现 DevOps 利大于弊，说的夸张些已经到了非转不可的地步内部混乱不堪，而且团队敏捷转型也快一年了，还是有很多问题，实现 DevOps 能够加速团队敏捷化。</p><p><img src="https://ahian-blog.oss-cn-beijing.aliyuncs.com/images/2020-05-19-060538.jpg" alt="什么是 DevOps？来源 AWS"></p><p>没有实现 DevOps 的企业就像坑坑洼洼的小路，要小心各种坑，而实现了 DevOps 就像一条刚修好的高速。我这样说有些不客观，但是对于我现在的公司来说确实如此。它能将需求管理、开发、测试、部署、运维串连到一起，及时反馈。</p><p>在当下市场环境，谁响应速度快、谁花费成本小谁就能活到最后。那么 DevOps 在理想的情况下能够提升价值的持续输出。</p><p>具体实施后续会逐一放出来。</p>]]></content>
    
    <summary type="html">
    
      DevOps 的成功落地，将会把研发效能从刀耕火种的时代提升到现代化
    
    </summary>
    
    
      <category term="DevOps" scheme="https://ahianzhang.com/categories/DevOps/"/>
    
    
      <category term="计划" scheme="https://ahianzhang.com/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq 如何提高可靠性并保证消费端幂等</title>
    <link href="https://ahianzhang.com/2020/03/29/rabbitmq-reliability/"/>
    <id>https://ahianzhang.com/2020/03/29/rabbitmq-reliability/</id>
    <published>2020-03-29T10:09:13.000Z</published>
    <updated>2020-03-29T15:10:54.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是消息的可靠性"><a href="#什么是消息的可靠性" class="headerlink" title="什么是消息的可靠性"></a>什么是消息的可靠性</h1><p>简单讲就是，一条消息由生产者发送出来，到 broker 上，存储到消息队列，再被消费者成功的消费。如果消息传着传着就传没了，此时消息就是不可靠的。</p><h1 id="为什么要提高消息可靠性"><a href="#为什么要提高消息可靠性" class="headerlink" title="为什么要提高消息可靠性"></a>为什么要提高消息可靠性</h1><p>拿订单或者交易举例，但凡涉及到与钱相关的系统，不允许出现任何数据偏差，如果因为在使用消息队列而丢失了数据，那这算是一个重大事故，好比你申请了几万元的退款，但是后台在发消息的时候恰好把你的这条退款消息丢了，还得去打客服电话，虽然钱不会少但是心里肯定会不爽。</p><h1 id="如何提高消息的可靠性"><a href="#如何提高消息的可靠性" class="headerlink" title="如何提高消息的可靠性"></a>如何提高消息的可靠性</h1><p><img src="https://ahian-blog.oss-cn-beijing.aliyuncs.com/images/2020-03-29-103429.png" alt="image-20200329183426043"></p><p>提高消息消息可靠性需要考虑什么情况下消息会丢失，如上图，可以分三个部分来讲（排除一些非正常的使用，比如说删队列、删交换机这样的）</p><h2 id="A：publisher-到-broker-之间可能出现的情况"><a href="#A：publisher-到-broker-之间可能出现的情况" class="headerlink" title="A：publisher 到 broker 之间可能出现的情况"></a>A：publisher 到 broker 之间可能出现的情况</h2><ul><li>消息发出去后网络出问题，没到 broker上</li><li>消息到达 broker 后没有对应的 exchange</li><li>消息到 exchange 后没有与之绑定的队列</li><li>生产者发送完消息后重启（不影响可靠性）</li></ul><h2 id="B-broker-可能出现的情况"><a href="#B-broker-可能出现的情况" class="headerlink" title="B: broker 可能出现的情况"></a>B: broker 可能出现的情况</h2><ul><li>broker 宕机情况</li></ul><h2 id="C-broker-到-consumer-可能出现的情况"><a href="#C-broker-到-consumer-可能出现的情况" class="headerlink" title="C: broker 到 consumer  可能出现的情况"></a>C: broker 到 consumer  可能出现的情况</h2><ul><li>消费者应用刚要处理消息，结果就重启了</li></ul><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><h3 id="针对-A-情况"><a href="#针对-A-情况" class="headerlink" title="针对 A 情况"></a>针对 A 情况</h3><p>官网提供两种确保消费者成功投递的方式，一种是使用<strong>事务</strong>，一种是使用 <strong>confirm 机制</strong>。对于具体如果使用本文不做展开，开启事务是一种昂贵的操作，官方建议使用 confirm 机制，能比事务机制快上 10倍左右，对于 confirm，一般使用 Spring AMQP 中的 ConfirmCallback 来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Confirmation callback.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> correlationData correlation data for the callback.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ack true for ack, false for nack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cause An optional cause, for nack, when available, otherwise null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">confirm</span><span class="params">(@Nullable CorrelationData correlationData, <span class="keyword">boolean</span> ack, @Nullable String cause)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 CorrelationData 是在发送端发送消息时一并发送的，里面有一个不可变的唯一 id，在 confirm 中尤为重要，可以利用它实现补偿机制。</p><p>Confirm 机制能够保证消息到达 broker 上并且<strong>有对应的交换机</strong>，但是不能保证是否路由到队列，此时就需要 ReturnCallback 来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReturnCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returned message callback.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message the returned message.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> replyCode the reply code.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> replyText the reply text.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> exchange the exchange.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> routingKey the routing key.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText,</span></span></span><br><span class="line"><span class="function"><span class="params">String exchange, String routingKey)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息到不了队列，就没法存储，此时会发生三种情况：</p><ol><li><p>直接丢弃</p></li><li><p>重新发送</p></li><li><p>转到另一个交换机上</p></li></ol><p>方式1，一般使用时不会采取直接丢弃的方式，风险较大</p><p>对于方式2，要配置 <strong>Mandatory</strong> 为 true，告诉 broker 说如果交换机找不到匹配的队列得把消息再返回给生产者。如果为 false 那就是第1种情况，此时需要注意重试的次数和方式，不能连续发送，需要留出异常的处理时间，比如重试三次，间隔5秒。</p><p>方式3，这是 rabbitmq 的一个功能，称为备份交换机（alternate-exchange），是在创建正常的交换机时追加一个 <code>alternate-exchange=&quot;XXX&quot;</code>的参数，XXX 为另一个交换机，接收无法路由的消息。</p><p>可能有人会发现，当消息无法路由到队列中，此时 ConfirmCallback 返回的 ack 为 true ，在这可能会有很多困惑，此处列出几种情况：</p><ul><li>消息投递到 exchange，触发 confirmCallback，成功为 true , 失败为 false（例如 exchange 不存在）</li><li>Exchange 无法路由到队列，此时触发 returnCallback 打印错误信息，再触发 confirmCallback，此时 <strong>ack = true</strong></li><li>消息正常路由到队列，只会触发 confirmCallback </li></ul><p>上面几种情况是针对于 Spring 实现的两个监听器，RabbitMQ 官方客户端实现可能不同。</p><p>对于发送者来说，消息到了 exchange 其实它的任务就已经完成了。</p><h3 id="针对-B-情况"><a href="#针对-B-情况" class="headerlink" title="针对 B 情况"></a>针对 B 情况</h3><p>此时我们说的主要是 broker 中的队列，因为 broker 中只有队列有存储功能，此时要保证队列的可靠性，需要设置持久化，能够保证 broker 重启后自动恢复数据。</p><ol><li>设置 exchange 持久化</li><li>声明队列时设置为持久化队列，这样能保证队列自身能够恢复（不包括里面的消息）</li><li>对消息设置 deliveryMode.PERSISTENT（默认，不需要改）</li></ol><p>搭配 publisher confirm 机制可以确保消息写到磁盘上以后才触发 confirmCallback，能够保证消息不丢失。</p><h3 id="针对-C-情况"><a href="#针对-C-情况" class="headerlink" title="针对 C 情况"></a>针对 C 情况</h3><p>大多数同学可能会对消费端 ack 比较熟，对于 Spring 环境来说，设置消费者手动 ack，broker 收到消费者 ack 后删除消息或者 nack 继续消费。</p><h1 id="消息补偿机制"><a href="#消息补偿机制" class="headerlink" title="消息补偿机制"></a>消息补偿机制</h1><p>此处的实现思路为：</p><ol><li>发送端创建 CorrelationData 对象跟随消息一同发送</li><li>将CorrelationData中的 id 作为key，发送的消息体为 value，存到本地缓存</li><li>当 confirm ack 为 true 时说明发送成功，根据返回的 CorrelationData id 将缓存中的对应数据删除</li><li>当 confirm ack 为 fasle 时说明失败了，此时根据 CorrelationData id 在缓存中拿到对应的消息重新发送</li><li>ReturnCallback 的重试机制在上面已经写出</li></ol><h1 id="消息幂等操作"><a href="#消息幂等操作" class="headerlink" title="消息幂等操作"></a>消息幂等操作</h1><p>生产端为了保证消息在投递过程中不丢失，会对一条消息多次重试，消费端没有手动 ack 导致重复消费，这些算是消息重复投递，在可靠性机制上无法避免，此时需要考虑如何多次处理同一条消息但是产生同样效果，即幂等。</p><p>保证幂等的方式因为业务的不同实现方式也不同，可以用 redis，可以用数据库主键，一个简单的思路：</p><ol><li><p>消费端获取消息的 MessageId 当作 key</p></li><li><p>消息内容当作 value</p></li><li><p>放到合适的容器中</p><p>拿 Map 举例，id 为 123 的消息，消费之前看 map 中是否存在 key=123，如果有的话跳过，没有的话处理消息并添加到map中。</p></li></ol><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.rabbitmq.com/blog/2011/02/10/introducing-publisher-confirms/" target="_blank" rel="noopener">https://www.rabbitmq.com/blog/2011/02/10/introducing-publisher-confirms/</a></p><p><a href="https://www.jianshu.com/p/6579e48d18ae" target="_blank" rel="noopener">https://www.jianshu.com/p/6579e48d18ae</a></p><p><a href="https://blog.51cto.com/4925054/2095467" target="_blank" rel="noopener">https://blog.51cto.com/4925054/2095467</a></p><p><a href="https://www.jianshu.com/p/8b77d4583bab" target="_blank" rel="noopener">https://www.jianshu.com/p/8b77d4583bab</a></p><p><a href="http://www.throwable.club/2018/11/25/rabbitmq-send-consume-confirm/" target="_blank" rel="noopener">http://www.throwable.club/2018/11/25/rabbitmq-send-consume-confirm/</a></p>]]></content>
    
    <summary type="html">
    
      rabbitmq 如何保证消息不丢失
    
    </summary>
    
    
      <category term="架构" scheme="https://ahianzhang.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="rabbitmq" scheme="https://ahianzhang.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>AMQ Model总结</title>
    <link href="https://ahianzhang.com/2020/03/21/rabbit-mq-basic-concept/"/>
    <id>https://ahianzhang.com/2020/03/21/rabbit-mq-basic-concept/</id>
    <published>2020-03-21T08:38:14.000Z</published>
    <updated>2020-03-24T02:51:13.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在写公司的消息队列组件，因为使用的是 RabbitMQ，其实现的规范是基于 AMQP-0-9-1 ，所以抽时间把官方的规范过了一遍，整理出主要的内容，记录于此。</p><h1 id="AMQ-模型架构-AMQ-Model-Architecture"><a href="#AMQ-模型架构-AMQ-Model-Architecture" class="headerlink" title="AMQ 模型架构(AMQ Model Architecture)"></a>AMQ 模型架构(<strong>AMQ Model Architecture</strong>)</h1><h2 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h2><p><img src="https://ahian-blog.oss-cn-beijing.aliyuncs.com/images/2020-03-21-091225.png" alt=""></p><ul><li>Publisher application 发送者</li><li>Consumer application 消费者</li><li>Server AMQP 服务器</li><li>Virtual host 在 Server 中提供逻辑隔离，类似于 MySQL 数据库中的多个表</li><li>Exchange 将消息根据不同的配置路由到不同队列</li><li>Message Queue 存储消息的地方</li></ul><h2 id="消息流转"><a href="#消息流转" class="headerlink" title="消息流转"></a>消息流转</h2><p><img src="https://ahian-blog.oss-cn-beijing.aliyuncs.com/images/2020-03-21-093617.png" alt=""></p><p>从上图可看出，AMQP 的关键之处和难点在于 Exchange 是如何将不同的消息发送到不同的 Message Queue 中</p><h2 id="消息的生命周期"><a href="#消息的生命周期" class="headerlink" title="消息的生命周期"></a>消息的生命周期</h2><p>在发送者发送消息和消费者确认消费，对于如何保证消息的可靠性，在 RabbitMQ 中有两种方式，一种是放到同一个事务中处理，但是这种方式对于并发量不大的可以使用，保证了准确性，但是牺牲了性能；还有一种是轻量级的通过 confirm 去异步确认，这部分以后会单独写出来。</p><p><img src="https://ahian-blog.oss-cn-beijing.aliyuncs.com/images/2020-03-22-135505.png" alt=""></p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列能将消息存到内存或者磁盘上，供消费者消费。它有几个主要的配置</p><ul><li>名称 name</li><li>专用 exclusive： 随 channel 创建和销毁</li><li>持久化 durable：broker 重启后能够恢复持久化的消息</li></ul><h3 id="队列生命周期"><a href="#队列生命周期" class="headerlink" title="队列生命周期"></a>队列生命周期</h3><ul><li>持久化队列</li><li>临时队列</li></ul><p><img src="https://ahian-blog.oss-cn-beijing.aliyuncs.com/images/2020-03-22-140750.png" alt="临时队列生命周期"></p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机，根据预先设定的 bindings 规范进行匹配和路由，exchange 根据 bindings 的信息决定应该将消息发送到哪个 queue 或者 exchange，exchange 此模块不存储任何消息，对于使用时我们一般说的是交换机的类型，就像车，有火车、汽车、自行车等，而 exchange 有四种类型，下面介绍常用的三种。</p><h3 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h3><p>AMQP 默认使用的是 direct 模式，此模式的特点是 routing key 和 bindings 必须匹配才能发送成功,如下图所示，如果 routing key 为 abc 的消息只能被 Consumer A 消费。</p><p><img src="https://ahian-blog.oss-cn-beijing.aliyuncs.com/images/2020-03-22-122824.png" alt=""></p><h3 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h3><p>topic 模式可以说是 direct 的一种扩展，这个扩展支持使用通配符来进行路由，规则是 <strong>#</strong> 代表一个单词，<strong>*</strong> 代表多个单词，下图中的消息能够被 Consumer A 和 Consumer C 消费，而 Consumer B 所监听的队列绑定的是 a.* ，最多只能是两个字母，不匹配。</p><p><img src="https://ahian-blog.oss-cn-beijing.aliyuncs.com/images/2020-03-22-123935.png" alt=""></p><h3 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h3><p>此模式也能叫做广播模式，此模式没有 routing key 的概念，发送方将消息发到 exchange 中，只要是有消息队列与之绑定就直接发送过去。</p><p><img src="https://ahian-blog.oss-cn-beijing.aliyuncs.com/images/2020-03-22-124807.png" alt=""></p><h3 id="exchange-生命周期"><a href="#exchange-生命周期" class="headerlink" title="exchange 生命周期"></a>exchange 生命周期</h3><p>在 borker 启动时会创建内部的交换机，这些交换机无法删除，还有一种就是应用创建（官方觉得叫 声明 更好），声明一个私有的交换机，私有的交换机可以被删除，但是在实际使用时声明出来以后不会再删。</p><h2 id="Routing-Key"><a href="#Routing-Key" class="headerlink" title="Routing Key"></a>Routing Key</h2><p>存在于发送者和 broker 之间，交换机会根据 routing key 将消息发送到对应的队列中。</p><h2 id="Bindings"><a href="#Bindings" class="headerlink" title="Bindings"></a>Bindings</h2><p>Bindings 存在于 exchange 和 message queue 之间，用来告诉 exchange 应该将消息路由到哪个队列上。</p><p>利用 bindings 可以实现</p><ul><li>共享队列(Shared Queue)：多个消费者监听同一个队列</li><li>应答队列(Reply Queue)：应用不声明队列，由 broker 临时生成一个队列进行消费</li><li>发布订阅队列(Pub/Sub Queue)：使用 topic 类型实现，结合 <code>bind()</code> 方法</li></ul><hr><p>除了以上的 AMQ 模型外，AMQP 还有命令、传输、功能、技术架构，这些等有时间再看。</p>]]></content>
    
    <summary type="html">
    
      关于 AMQP 0-9-1 中的 AMQ 模型架构知识整理
    
    </summary>
    
    
      <category term="协议" scheme="https://ahianzhang.com/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="rabbitmq" scheme="https://ahianzhang.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>结对编程</title>
    <link href="https://ahianzhang.com/2019/12/26/pair-programming/"/>
    <id>https://ahianzhang.com/2019/12/26/pair-programming/</id>
    <published>2019-12-26T05:03:24.000Z</published>
    <updated>2019-12-26T05:41:02.429Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发中常常在同一组内的成员虽然都负责同一个系统，但基本上是自己开发自己的，这样所带来的问题就是如果一个人请假了并且他负责模块出了问题急需解决，而此时团队的其他小伙伴要一点一点地扒代码，小心翼翼的闭坑，这应该是国内中小公司的常态。而结对编程恰好能解决这样的问题。</p><p>结对编程来源于Extreme programming（XP），常常与 TDD 一同使用，对开发人员的要求较高，但是产出的代码质量也会提升，常用的结对编程有两种模式：</p><h3 id="driver-navigator"><a href="#driver-navigator" class="headerlink" title="driver-navigator"></a><em>driver</em>-<em>navigator</em></h3><p>用俗一点的话来讲这样模式就是，新手和老司机，就像考驾照的时候，你坐在驾驶位而教练坐在副驾，教你什么时候该干嘛。dirver-navigator 在公司场景的应用就是一个新入职的员工或者学员由一个经验丰富的程序员带着，这样的好处是能快速填补空缺，让新员工尽快实现自己的价值。</p><h3 id="ping-pong"><a href="#ping-pong" class="headerlink" title="ping-pong"></a><strong>ping-pong</strong></h3><p>这种模式就是想我们平时玩的乒乓球，你打过来我打回去，适合两个水平相当的人共同开发，结合 TDD 的做法就是一个人先写好一个测试用例，然后交由伙伴去实现这个测试用例，然后再设计一个测试用例教回到之前的伙伴继续做实现，如此往复，这样的好处是两者都熟悉彼此的代码，在开发的过程中都有时间思考更好的思路。</p><p>还有就是像那种远程协同的，就需要借助一些工具来进行代码协作，像 VSCode LiveShare，JetBrains 官方目前还没有对应的工具。</p><p>以上就是有关结对编程的基础概念普及，个人建议即使用不到也需要了解一下。</p>]]></content>
    
    <summary type="html">
    
      本文会让你对结对编程有一个简单的认识
    
    </summary>
    
    
      <category term="XP" scheme="https://ahianzhang.com/categories/XP/"/>
    
    
      <category term="极限编程" scheme="https://ahianzhang.com/tags/%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>RSocket 介绍</title>
    <link href="https://ahianzhang.com/2019/12/10/rsocket-intro/"/>
    <id>https://ahianzhang.com/2019/12/10/rsocket-intro/</id>
    <published>2019-12-10T06:36:49.000Z</published>
    <updated>2019-12-24T09:42:20.417Z</updated>
    
    <content type="html"><![CDATA[<p>RSocket 是一个新的通信协议， Facebook、Netfi、Pivotal、vlingo 等公司都有参与研发，它是一个位于传输层的新协议。在反应式编程中有两个瓶颈，一个是关系型数据库性能，一个是网络传输性能，对于数据库已经有<a href="https://r2dbc.io/" target="_blank" rel="noopener">r2dbc</a>开发，而网络问题则由 RScoket 解决，有人说 VaughnVernon 去 vlingo 做 RSocket 研究是为了解决领域驱动设计中上下文映射的问题（未求证）</p><h2 id="为什么需要一个新协议"><a href="#为什么需要一个新协议" class="headerlink" title="为什么需要一个新协议"></a>为什么需要一个新协议</h2><p>按<a href="http://rsocket.io/docs/FAQ" target="_blank" rel="noopener">官方的解释</a>翻译以及个人理解：</p><ul><li>为了支持除了目前最常用的 Request/Respones 以外，像流式响应（类似于 Flink 的流处理）以及推送</li><li>二进制协议，使用字节流传输，支持单连接的多路复用</li><li>会话重连，这在移动端上很有用</li><li>需要有一个应用层的协议来支持自由切换像 WebSockets 和 Aeron 这样的传输层协议</li></ul><h2 id="支持的四种通讯模型"><a href="#支持的四种通讯模型" class="headerlink" title="支持的四种通讯模型"></a>支持的四种通讯模型</h2><table><thead><tr><th>名称</th><th>用途</th></tr></thead><tbody><tr><td>Request/Response</td><td>rpc</td></tr><tr><td>Request/Stream</td><td>pub/sub</td></tr><tr><td>Fire-and-Forget</td><td>logging, metrics</td></tr><tr><td>channel</td><td>mobile &amp; IoT <-> Server 全双工通道</td></tr></tbody></table><h2 id="Reactive"><a href="#Reactive" class="headerlink" title="Reactive"></a>Reactive</h2><p>RSocket 实现了 Reactive 编程模型，它有以下特点</p><ul><li>全异步无阻塞</li><li>背压</li><li>并发模型 </li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.infoq.cn/article/2018%2F10%2Frsocket-facebook" target="_blank" rel="noopener">https://www.infoq.cn/article/2018%2F10%2Frsocket-facebook</a></p><p><a href="https://www.ibm.com/developerworks/cn/java/j-using-rsocket-for-reactive-data-transfer/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-using-rsocket-for-reactive-data-transfer/index.html</a></p><p><a href="https://en.wikipedia.org/wiki/RSocket" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/RSocket</a></p><p><a href="https://dev.to/petros0/getting-started-with-rsocket-in-springboot-5889" target="_blank" rel="noopener">https://dev.to/petros0/getting-started-with-rsocket-in-springboot-5889</a></p><p><a href="http://rsocket.io/docs/FAQ" target="_blank" rel="noopener">http://rsocket.io/docs/FAQ</a></p><p>## </p>]]></content>
    
    <summary type="html">
    
      本文会让读者对 Rsocket 有一个基础的认识
    
    </summary>
    
    
      <category term="协议" scheme="https://ahianzhang.com/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="rsocket" scheme="https://ahianzhang.com/tags/rsocket/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的理解</title>
    <link href="https://ahianzhang.com/2019/10/08/object-oriented-mind/"/>
    <id>https://ahianzhang.com/2019/10/08/object-oriented-mind/</id>
    <published>2019-10-08T04:12:20.000Z</published>
    <updated>2019-11-08T11:54:09.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>说起面向对象的特征，大多数人肯会不加思索的答封装、继承、多态，可能还有抽象。最近在学 DDD 的时候，感觉它更加合理的运用了设计模式和面向对象的思想去解决复杂的业务场景，还有是阅读源码的时候也会看到大量的设计模式，所以说 Design Pattern 和 Object-Oriented 熟练的话会提升很大的代码质量（编程范式后续还会讲函数式和响应式）。</p><p>下面只说自己的体会和见解，如有异议欢迎留言。</p><h1 id="四大特征"><a href="#四大特征" class="headerlink" title="四大特征"></a>四大特征</h1><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>抽象，隐藏与上下文无关的信息，抽象的目的是为了简单，从宏观的角度去处理问题，举例：你开车去上班，但你只要知道车能带你到公司而不用在乎车内部的复杂零件是如何做工的，此时车就抽象成为一个整体。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>将功能相近的代码放到同一个类中，这样做的好处是能够进行解耦让不同的代码各司其职，具体细分为 <strong>Information hiding</strong> 和 <strong>Implementation hiding</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 通过 访问修饰符 讲一些细节保留在当前类中，而一些相对外开放的则使用 public 进行修饰</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InformationHiding</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//Restrict direct access to inward data</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList items = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Provide a way to access data - internal logic can safely be changed in future</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList <span class="title">getItems</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ImplemenatationHiding</span> </span>&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">sumAllItems</span><span class="params">(ArrayList items)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InformationHiding</span> <span class="keyword">implements</span> <span class="title">ImplemenatationHiding</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//Restrict direct access to inward data</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList items = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Provide a way to access data - internal logic can safely be changed in future</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList <span class="title">getItems</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">sumAllItems</span><span class="params">(ArrayList items)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Here you may do N number of things in any sequence</span></span><br><span class="line">        <span class="comment">//Which you do not want your clients to know</span></span><br><span class="line">        <span class="comment">//You can change the sequence or even whole logic</span></span><br><span class="line">        <span class="comment">//without affecting the client</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承就是子类继承父类并可以父类或者重写父类的方法，这样做能让基础功能代码复用，但是现在有一种说法是组合优先于继承，因为继承也有自身的局限性，容易把代码写死。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>这里的个人理解就是一段代码写在不同的业务场景下有不同的功能，通过重载或者重写，其正规的说法是：</p><blockquote><p>In java language, polymorphism is essentially considered into two versions:</p><ul><li>Compile time polymorphism (static binding or <strong>method overloading</strong>)</li><li>Runtime polymorphism (dynamic binding or <strong>method overriding</strong>)</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      对于面向对象，一直处于背书的状态，直到最近接触到底层设计才发现 OO 思想在 Java 语言中的重要性
    
    </summary>
    
    
      <category term="架构" scheme="https://ahianzhang.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="面向对象" scheme="https://ahianzhang.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>企业平台技术框架</title>
    <link href="https://ahianzhang.com/2019/09/27/architecture-framework/"/>
    <id>https://ahianzhang.com/2019/09/27/architecture-framework/</id>
    <published>2019-09-27T03:50:35.000Z</published>
    <updated>2019-10-07T12:28:41.548Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了阿里的 TMF2.0 交易平台的介绍，觉得很有兴趣，所以展开学习，因为认知以及自身水平，对于技术平台框架理解有限，如有不当之处还望斧正。</p><p>在说 TMF2.0 之前先来说说 TOGAF。</p><p><a href="https://www.opengroup.org/togaf" target="_blank" rel="noopener">TOGAF</a> 全称 The Open Group Architecture Framework，及开放组织结构框架，引用 WiKi 上的介绍：</p><blockquote><p><strong>开放组体系结构框架</strong>（英语：The Open Group Architecture Framework，缩写：<strong>TOGAF</strong>）是一个<a href="https://zh.wikipedia.org/wiki/企业架构" target="_blank" rel="noopener">企业架构</a>框架，它提供了一种设计，规划，实施和管理企业信息技术架构的方法<a href="https://zh.wikipedia.org/wiki/开放组体系结构框架#cite_note-2" target="_blank" rel="noopener">[2]</a>。TOGAF是一种高层设计方法。 它通常被建模为四个级别：业务，应用程序，数据，和技术。 它在很大程度上依赖于模块化，标准化以及已有的，经过验证的技术和产品。</p></blockquote><p>其实个人认为这种框架只不过是给企业一个参考，怎么落地还要结合自身所处的环境，一口吃不成一个胖子，好比技术创业，首先要有创意，其次是写代码，然后看能不能盈利，如果一直亏损那么所谓的架构也就无从谈起了。</p><p>对于阿里系的 TMF2.0 它的诞生是为了解决问题的，当然新技术或者方案的出现都是为了解决现有问题，不然有谁愿意做无用功。 TMF2.0站在了一个全局的视角上，着重解决需求结构化，业务配置化以及 SRE，基于业务场景划分职责，使代码逻辑更清晰。这套技术平台上线后能大大的缩短开发周期，这对当前快变的市场来说是非常受益的。</p><p>参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/32253578" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32253578</a></p><p><a href="http://blog.itpub.net/31562044/viewspace-2639289/" target="_blank" rel="noopener">http://blog.itpub.net/31562044/viewspace-2639289/</a></p><p><a href="http://blog.itpub.net/31562044/viewspace-2639289/" target="_blank" rel="noopener">http://blog.itpub.net/31562044/viewspace-2639289/</a>    </p>]]></content>
    
    <summary type="html">
    
      技术的出现必然是为了解决实际的问题，否则毫无价值
    
    </summary>
    
    
      <category term="架构" scheme="https://ahianzhang.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="平台架构" scheme="https://ahianzhang.com/tags/%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>对创业的思考</title>
    <link href="https://ahianzhang.com/2019/09/27/summary13/"/>
    <id>https://ahianzhang.com/2019/09/27/summary13/</id>
    <published>2019-09-27T02:21:02.000Z</published>
    <updated>2019-09-27T02:51:37.009Z</updated>
    
    <content type="html"><![CDATA[<p>在我还在读大学的时候就创业的想法，所以平时也会对创业的方面的内容更关注一些，加上平时的思考与感悟整理出来。</p><h1 id="活着"><a href="#活着" class="headerlink" title="活着"></a>活着</h1><p>对于创业可能常听到“十个创业九个死”之类的话，对于一个初创公司来说没有比活下来更重要了，作为经营者要考虑成本，说利益至上可能显得又些不道德，但是现实就是如此。</p><h1 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h1><p><strong>公司应该在保证核心目标不变的前提下做到快变</strong>，这里的快变是指跟随市场变化</p><p><strong>拒绝跟风</strong>跟风在互联网很常见，一个 APP 出了一个新功能，投入市场后吸引力很多用户，其他公司看到了利益，也会要求自己的产品加上相同的功能。但这样一旦成为市场常态那么就不会再吸引用户了。</p><h1 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h1><p>企业的核心竞争力在于有一套不可复制的模式，这也是企业能够活下去的根本，如果不做创新那还叫什么创业呢。</p><h1 id="文化"><a href="#文化" class="headerlink" title="文化"></a>文化</h1><p>企业文化可以说相当重要，以前总觉得踏踏实实做事就行，但接触的多了才发现，没有思想你一文不值，没有思想就如同一台机器，一台机器可以随意的替换和批量生产。对于企业来说，保证对公司的初衷不变的前提下融合成员的思想，在创业上应该保持“道不同，不相为谋”的心态。当然好的企业文化都是沉淀下来的，所以说活着高于一切。对于人才的培养以及忠诚度我把它归为文化里，没有什么死的标准指导，因时制宜才是最好的。</p>]]></content>
    
    <summary type="html">
    
      创业主要在于创新
    
    </summary>
    
    
      <category term="总结" scheme="https://ahianzhang.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="创业" scheme="https://ahianzhang.com/tags/%E5%88%9B%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>知难行易</title>
    <link href="https://ahianzhang.com/2019/09/22/summary12/"/>
    <id>https://ahianzhang.com/2019/09/22/summary12/</id>
    <published>2019-09-22T07:15:14.000Z</published>
    <updated>2019-09-22T08:28:22.693Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人们总是用自己的认知限制，来否认事物的存在</p></blockquote><p>”认知提升“应该是近几年频繁会听到的短语。一个人的认知决定了这个人站在什么高度去看待问题。最近接触了一些人一些事感觉确实如此。</p><p>今年的世界人工智能大会开幕式马云和马斯克的谈话，个人更喜欢马斯克的想法，不局限于当下，敢作敢为。人类早晚都会在宇宙中生存，我们所做的只是促进或者减缓时代的到临，却无法阻止。</p><p>在软件工程中，有面向对象的思维，有各种设计模式，这是最基础的然而也是大多数人忽略的，问什么是面向对象，总是答封装继承和多态，继续问面向对象的设计原则，此时估计会卡掉一大半。工作了一年有余，接触的东西多了，才逐渐明白新的技术或者框架并不是应该追逐的东西，最基础的才是最难的，像打地基，怎么打才能让其稳定负重，如果连设计模式都不清楚的话很难写出优秀的代码。</p><p>知难，每个人都是懒惰的，都有惯性思维，但恰恰如此，只在自己熟悉的领域做事情，用不了多久就会废掉，这种人不愿改变自己的观念，也常常自欺欺人，在如今应该会被称为“社畜”吧。</p><p>“信则有，不信则无”，它一直存在于那里，只是愿不愿意承认。</p><p>行易，如果你的认知能够作为实践的理论基础，那么做不做只是选择问题。</p><p>知行合一，是阳明学说的核心思想，如果说知难行易，那么知行合一则是更上一次的思想，有难便有易，万物总是存在对立面，如果能使二者达到某种平衡，那么其带来的影响必然是巨大的。</p><p>平时多思考、多和有见识的人交流，是提升自己认知最好的方式。</p>]]></content>
    
    <summary type="html">
    
      阳明先生所说知行合一在物欲横流的时代能有几人做到
    
    </summary>
    
    
      <category term="总结" scheme="https://ahianzhang.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="生活总结" scheme="https://ahianzhang.com/tags/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>一年工作经验总结</title>
    <link href="https://ahianzhang.com/2019/09/03/summary11/"/>
    <id>https://ahianzhang.com/2019/09/03/summary11/</id>
    <published>2019-09-03T07:58:48.000Z</published>
    <updated>2019-09-03T08:50:55.558Z</updated>
    
    <content type="html"><![CDATA[<p>从 17 年开始到现在断断续续的写了一百多篇博客，每次看到以前写的博客都很感慨，浏览之前的博客其实能感受到这几年的变化与成长，但最近想了一下决定删除一些文章，从技术的关注向深度转变，方向可以从分类中看到，获取短期内不会再发生什么变化了，这是一次重要的选择，想要得到就要先放弃。</p><h1 id="工作内容"><a href="#工作内容" class="headerlink" title="工作内容"></a>工作内容</h1><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ul><li>重构搜索系统</li><li>设计并编写微服务环境下统一用户管理系统</li><li>代码规范的强制实施</li><li>日志监控报警</li><li>会刷 leetcode 算法题了</li></ul><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ul><li>技术本身并没有价值</li><li>认知升级</li><li>把一件事做简单，把简单事做极致</li><li>领域驱动设计</li><li>二八原则</li></ul><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><ul><li>终于有成品了，之前就像总像蜻蜓点水一样，觉得什么都会，但没有实战经验。</li><li>对 Spring IoC 和 AOP 有了更深的理解</li><li>对代码的质量有了更严苛的要求</li><li>认识到些单元测试的重要性</li><li>能用自动化的就不要手工操作</li><li>成本和投入产出比</li></ul>]]></content>
    
    <summary type="html">
    
      2018.8.1-2019.8.1
    
    </summary>
    
    
      <category term="总结" scheme="https://ahianzhang.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="工作总结" scheme="https://ahianzhang.com/tags/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>我与领域驱动之缘</title>
    <link href="https://ahianzhang.com/2019/07/30/ddd-01/"/>
    <id>https://ahianzhang.com/2019/07/30/ddd-01/</id>
    <published>2019-07-30T06:59:00.000Z</published>
    <updated>2020-07-08T02:54:05.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>正式接触到领域驱动还是耗子叔在易观峰会上的演讲，当时听的一知半解，现在回头来看一看真的很棒。</p><p><img src="https://ahian-blog.oss-cn-beijing.aliyuncs.com/images/2020-07-08-025402.jpg" alt="WechatIMG23"></p><h1 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h1><p>领域驱动设计适用于复杂的业务系统，但对于那些简单的使用 DDD 反而会增加复杂度。</p><p>最近在读 Vaughn Vernon 《实现领域驱动设计》以及张逸写的领域驱动设计战略篇和战术篇，</p><p>收益良多。</p>]]></content>
    
    <summary type="html">
    
      领域驱动是目前我认为解决业务系统复杂度的最好方式
    
    </summary>
    
    
      <category term="DDD" scheme="https://ahianzhang.com/categories/DDD/"/>
    
    
      <category term="概述" scheme="https://ahianzhang.com/tags/%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>TDD 中使用的工具</title>
    <link href="https://ahianzhang.com/2019/07/30/test-tool/"/>
    <id>https://ahianzhang.com/2019/07/30/test-tool/</id>
    <published>2019-07-30T04:26:59.000Z</published>
    <updated>2019-09-03T01:44:15.302Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h3><p>常用单元测试工具</p><h3 id="MockMvc"><a href="#MockMvc" class="headerlink" title="MockMvc"></a>MockMvc</h3><p>Spring 提供的模拟 Controller 接口调用的工具</p><h3 id="Mocktio"><a href="#Mocktio" class="headerlink" title="Mocktio"></a>Mocktio</h3><p>能够提供 Mock 方法</p><h3 id="Cucumber"><a href="#Cucumber" class="headerlink" title="Cucumber"></a>Cucumber</h3><p>行为驱动开发，以用户故事为核心，算是 TDD 的升级版，能够结合其他工具生成报表</p>]]></content>
    
    <summary type="html">
    
      Java 语言中常用的开发工具
    
    </summary>
    
    
      <category term="TDD" scheme="https://ahianzhang.com/categories/TDD/"/>
    
    
      <category term="测试工具" scheme="https://ahianzhang.com/tags/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>tf-idf 算法</title>
    <link href="https://ahianzhang.com/2019/07/03/tf-idf/"/>
    <id>https://ahianzhang.com/2019/07/03/tf-idf/</id>
    <published>2019-07-03T00:54:36.000Z</published>
    <updated>2019-09-05T02:22:23.550Z</updated>
    
    <content type="html"><![CDATA[<p>tf-idf (term frequence-inverse document frequence) 词频-逆文档频率，是搜索常用的一个权重相关算法，其作用是评估一个 document 在一整个 document list 中的重要程度，下面分开来讲。</p><h2 id="term-frequence"><a href="#term-frequence" class="headerlink" title="term frequence"></a>term frequence</h2><p>tf 的意思就是一个词语在一个文件中出现的次数，对于一篇文章， tf 算法会将这篇文章进行分词并统计出现次数。这个词在这篇文章中出现的次数越多则说明越不重要，权重则越低。</p><p>其公式如下：</p><p>$$词频(tf_t,d)=\frac{单词在文档中出现的次数}{文档的总次数}$$</p><h2 id="inverse-document-frequence"><a href="#inverse-document-frequence" class="headerlink" title="inverse document frequence"></a>inverse document frequence</h2><p>先说文档频率(df)，表示文档集中包含某个词的所有文档数目。但是通常这个数目会很大，对此可以使用逆文档将其映射成小的取值范围，逆文档频率公式如下：</p><p>$$逆文档频率(idf_t)=log(\frac{文档集总数}{包含某个词的文档数})=log(\frac{N}{df_t+1})$$</p><h1 id="tf-idf"><a href="#tf-idf" class="headerlink" title="tf-idf"></a>tf-idf</h1><p>公式如下:</p><p>$$词频-逆文档频率(tf-idf)= 词频(tf) \times 逆文档频率(idf)$$</p><h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TfIdf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 词频</span></span><br><span class="line"><span class="comment">     * 此数值越大则代表这个 term 在当前文档中越重要</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> doc</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> term</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">tf</span><span class="params">(List&lt;String&gt; doc, String term)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> termFrequency = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String str : doc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.equalsIgnoreCase(term)) &#123;</span><br><span class="line">                termFrequency++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> termFrequency / doc.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文档频率</span></span><br><span class="line"><span class="comment">     * 此值会越高越说明不重要</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> docs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> term</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 存在 term 的文档数目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">df</span><span class="params">(List&lt;List&lt;String&gt;&gt; docs, String term)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (term != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(term)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (List&lt;String&gt; doc : docs) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String word : doc) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (term.equalsIgnoreCase(word)) &#123;</span><br><span class="line">                        n++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"term 不能为 null 或者空字符串"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 逆文档频率</span></span><br><span class="line"><span class="comment">     * 此值越小则说明当前 term 越不重要</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> docs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> term</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">idf</span><span class="params">(List&lt;List&lt;String&gt;&gt; docs, String term)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.log(docs.size() / df(docs, term) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">tfIdf</span><span class="params">(List&lt;String&gt; doc, List&lt;List&lt;String&gt;&gt; docs, String term)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tf(doc, term) * idf(docs, term);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; doc1 = Arrays.asList(<span class="string">"北京"</span>, <span class="string">"上海"</span>, <span class="string">"杭州"</span>);</span><br><span class="line">        List&lt;String&gt; doc2 = Arrays.asList(<span class="string">"北京"</span>, <span class="string">"深圳"</span>, <span class="string">"南京"</span>);</span><br><span class="line">        List&lt;String&gt; doc3 = Arrays.asList(<span class="string">"南京"</span>, <span class="string">"北京"</span>, <span class="string">"深圳"</span>);</span><br><span class="line">        List&lt;String&gt; doc4 = Arrays.asList(<span class="string">"上海"</span>, <span class="string">"广州"</span>, <span class="string">"云南"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; documents = Arrays.asList(doc1, doc2, doc3, doc4);</span><br><span class="line"></span><br><span class="line">        TfIdf tfIdf = <span class="keyword">new</span> TfIdf();</span><br><span class="line">        System.out.println(<span class="string">"【北京】在 doc1 中的词频："</span> + tfIdf.tf(doc1, <span class="string">"北京"</span>));</span><br><span class="line">        System.out.println(<span class="string">"【北京】在 doc4 中的词频："</span> + tfIdf.tf(doc4, <span class="string">"北京"</span>));</span><br><span class="line">        System.out.println(<span class="string">"【北京】在 文档集 中的词频："</span> + tfIdf.df(documents, <span class="string">"北京"</span>));</span><br><span class="line">        System.out.println(<span class="string">"【北京】的 if-idf 算法："</span> + tfIdf.tfIdf(doc2, documents, <span class="string">"北京"</span>));</span><br><span class="line">        System.out.println(<span class="string">"【深圳】的 if-idf 算法："</span> + tfIdf.tfIdf(doc2, documents, <span class="string">"深圳"</span>));</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 【北京】在 doc1 中的词频：0.3333333333333333</span></span><br><span class="line"><span class="comment">         * 【北京】在 doc4 中的词频：0.0</span></span><br><span class="line"><span class="comment">         * 【北京】在 文档集 中的词频：3</span></span><br><span class="line"><span class="comment">         * 【北京】的 if-idf 算法：0.23104906018664842</span></span><br><span class="line"><span class="comment">         * 【深圳】的 if-idf 算法：0.3662040962227032</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《从 Lucene 到 Elasticsearch 全文检索实战》</p>]]></content>
    
    <summary type="html">
    
      tf-idf 算法的相关内容
    
    </summary>
    
    
      <category term="搜索" scheme="https://ahianzhang.com/categories/%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="算法" scheme="https://ahianzhang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>gitlab 添加代码规范检测</title>
    <link href="https://ahianzhang.com/2019/06/19/code-style-check-ali-p3c/"/>
    <id>https://ahianzhang.com/2019/06/19/code-style-check-ali-p3c/</id>
    <published>2019-06-19T03:00:46.000Z</published>
    <updated>2019-07-30T03:54:04.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>gitlab 10.5.X + gitlab + ali p3c.pmd</p><p>好的代码能让人赏心悦目，方便 CodeReview 进行，为此，必须强制性的将代码规范起来。</p><h1 id="如何做"><a href="#如何做" class="headerlink" title="如何做"></a>如何做</h1><h2 id="git-custom-hooks"><a href="#git-custom-hooks" class="headerlink" title="git custom hooks"></a>git custom hooks</h2><h3 id="client-hooks"><a href="#client-hooks" class="headerlink" title="client hooks"></a>client hooks</h3><p>客户端钩子是存在本地的，按项目去配，这样能达到目的，但是起不到强制约束的效果，而且一个一个配很麻烦</p><h3 id="server-hooks"><a href="#server-hooks" class="headerlink" title="server hooks"></a>server hooks</h3><p>服务器端的钩子，每个项目中的 git hooks 全都是软连接到 gitlab  上的一个位置，默认是在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/gitlab/embedded/service/gitlab-shell/hooks</span><br></pre></td></tr></table></figure><p>这个 hooks 文件夹内包括三个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── post-receive</span><br><span class="line">├── pre-receive</span><br><span class="line">└── update</span><br></pre></td></tr></table></figure><ul><li>pre-receive 接收客户端推送的代码，这个脚本的功能是最后只有 exit 0 时才代表接收，所有非 0 的推送都会被拒绝</li><li>update 可以多分支的去检测，即一段代码推送到多个分支，每个分支更新代码前都会执行一次这个脚本</li><li>post-receive 这个脚本是最后执行的，主要用来记录信息及通知用，不能中断推送流程</li></ul><p>按实际需求，使用 pre-receive 脚本就能满足要求，修改脚本为如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">export</span> LANG=<span class="string">"en_US.UTF-8"</span></span><br><span class="line">REJECT=0</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> oldrev newrev refname; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$oldrev</span>"</span> = <span class="string">"0000000000000000000000000000000000000000"</span> ];<span class="keyword">then</span></span><br><span class="line">        oldrev=<span class="string">"<span class="variable">$&#123;newrev&#125;</span>^"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    files=`git diff --name-only <span class="variable">$&#123;oldrev&#125;</span> <span class="variable">$&#123;newrev&#125;</span>  | grep -e <span class="string">"\.java$"</span>`</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$files</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        TEMPDIR=<span class="string">"tmp"</span></span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> <span class="variable">$&#123;files&#125;</span>; <span class="keyword">do</span></span><br><span class="line">            mkdir -p <span class="string">"<span class="variable">$&#123;TEMPDIR&#125;</span>/`dirname <span class="variable">$&#123;file&#125;</span>`"</span> &gt;/dev/null</span><br><span class="line">            git show <span class="variable">$newrev</span>:<span class="variable">$file</span> &gt; <span class="variable">$&#123;TEMPDIR&#125;</span>/<span class="variable">$&#123;file&#125;</span></span><br><span class="line">        <span class="keyword">done</span>;</span><br><span class="line"></span><br><span class="line">        files_to_check=`find <span class="variable">$TEMPDIR</span> -name <span class="string">'*.java'</span>`</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">         /home/jdk1.8.0_212/bin/java -cp /home/p3c-pmd-1.3.6.jar net.sourceforge.pmd.PMD -d <span class="variable">$TEMPDIR</span> -R rulesets/java/ali-comment.xml,rulesets/java/ali-concurrent.xml,rulesets/java/ali-constant.xml,rulesets/java/ali-exception.xml,rulesets/java/ali-flowcontrol.xml,rulesets/java/ali-naming.xml,rulesets/java/ali-oop.xml,rulesets/java/ali-orm.xml,rulesets/java/ali-other.xml,rulesets/java/ali-set.xml -f text</span><br><span class="line">       </span><br><span class="line">         REJECT=$?</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">          <span class="keyword">if</span> [[ <span class="variable">$REJECT</span> == 0 ]] ;<span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> -e <span class="string">"\033[32m恭喜你代码通过质量检测！\033[0m"</span></span><br><span class="line">             <span class="keyword">else</span> <span class="built_in">echo</span> -e <span class="string">"\033[31m\033[01m 请及时修改代码并再次尝试\033[0m"</span> </span><br><span class="line">          <span class="keyword">fi</span></span><br><span class="line">     </span><br><span class="line">        rm -rf <span class="variable">$TEMPDIR</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="variable">$REJECT</span></span><br></pre></td></tr></table></figure><p>上面代码是根据简书上的一个 blog 做了微调，如果你要用的话只需要修改 java 路径和 p3c.jar 的路径，这个脚本接受的是标准输入流，具体可以查看下方链接。</p><p>参考链接：</p><p><a href="https://www.jianshu.com/p/b87ca8615c9c" target="_blank" rel="noopener">如何生成整合了阿里巴巴JAVA编码规范的PMD包配合GitLab提升团队代码质量</a></p><p><a href="https://www.jianshu.com/p/5531a21afa68" target="_blank" rel="noopener">Gitlab 服务器端 custom hook 配置</a></p><p><a href="[https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90](https://git-scm.com/book/zh/v2/自定义-Git-Git-钩子">自定义 Git - Git 钩子</a>)</p><p><a href="https://gitirc.eu/githooks.html" target="_blank" rel="noopener">githooks(5) Manual Page</a></p><p><a href="https://www.jianshu.com/p/de90ffbd53e9" target="_blank" rel="noopener">使用git钩子对提交代码进行检查(pre-commit)</a></p>]]></content>
    
    <summary type="html">
    
      在推代码规范的路上一定要独裁
    
    </summary>
    
    
      <category term="架构" scheme="https://ahianzhang.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>query 改写</title>
    <link href="https://ahianzhang.com/2019/06/18/query-rewrite/"/>
    <id>https://ahianzhang.com/2019/06/18/query-rewrite/</id>
    <published>2019-06-18T07:36:03.000Z</published>
    <updated>2019-06-19T07:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-query-改写"><a href="#什么是-query-改写" class="headerlink" title="什么是 query 改写"></a>什么是 query 改写</h1><p>query 改写是搜索系统中最基础也是最重要的一个模块，简单来讲就是把用户输入的 keyword 转换成最贴近搜索系统内部的可识别的 keyword。</p><p>搜索引擎检索 keyword 的时候主要是匹配和排序，匹配也常常被称作“召回”，在搜索和推荐领域会有一个“召回率”的指标，在此不做展开。query 改写则会直接影响召回的指标</p><p>query 改写可以分成几个大的功能：纠错（ERROR Correction）、意图改写、记录 keyword</p><p>举个电商行业的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用户搜索关键字: 男士鞋</span><br><span class="line"></span><br><span class="line">倒排索引：</span><br><span class="line"> doc1: 男士鞋白色百搭</span><br><span class="line"> doc2: 男鞋红色运动型</span><br><span class="line"> doc3: 鞋子蓝色透气舒适</span><br><span class="line"> doc4: 女生跑步鞋</span><br></pre></td></tr></table></figure><p>如果不进行 query 改写那么它就会返回在索引中与 “男士鞋” 完全匹配的文档，此时只有 doc1 能够被召回，此时显然不是我们想要的，如果 改写 query 会是什么样的？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">男士鞋 -&gt; 男|男士|鞋</span><br></pre></td></tr></table></figure><p>将 keyword 按一定的逻辑进行拆分，然后推测用户想要搜什么，也就是拆分后的字或者词哪个是重要的。这样就能返回 doc1 和 doc2 以及可能会返回 doc3 ，这就有一定的概率性，牺牲一定的准确度来获得更多商品的召回。</p><h1 id="怎么去做-query-改写"><a href="#怎么去做-query-改写" class="headerlink" title="怎么去做 query 改写"></a>怎么去做 query 改写</h1><ul><li>n-gram （N 元语法模型）</li><li>知识图谱</li><li>协同过滤</li></ul><p>​    <strong>n</strong>-<strong>gram</strong></p>]]></content>
    
    <summary type="html">
    
      叙述自己目前对 query 改写的一些认知
    
    </summary>
    
    
      <category term="搜索" scheme="https://ahianzhang.com/categories/%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="理论" scheme="https://ahianzhang.com/tags/%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
</feed>
