<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="学习、思考、记录"><title>50道Java线程问题(下) | 象帝浮华生</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-99206993-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">50道Java线程问题(下)</h1><a id="logo" href="/.">象帝浮华生</a><p class="description">总要有一个地方来沉淀自己。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/translate/"><i class="fa fa-file-text"> 翻译</i></a><a href="/gist/"><i class="fa fa-github"> Gist</i></a><a href="/mindmap/"><i class="fa fa-globe"> Mindmap</i></a><a href="/rss"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">50道Java线程问题(下)</h1><div class="post-meta">Nov 28, 2017<span> | </span><span class="category"><a href="/categories/后端/">后端</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a href="/2017/11/28/java6/#SOHUCS" class="ds-thread-count"><span id="changyan_count_unit" style="font-size: 15px; color: #6E7173;">0</span><span> 条评论</span></a><script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js" async></script><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何写代码来解决生产者消费者问题？"><span class="toc-number">1.</span> <span class="toc-text">如何写代码来解决生产者消费者问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何避免死锁？"><span class="toc-number">2.</span> <span class="toc-text">如何避免死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中活锁和死锁有什么区别？"><span class="toc-number">3.</span> <span class="toc-text">Java中活锁和死锁有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么检测一个线程是否拥有锁？"><span class="toc-number">4.</span> <span class="toc-text">怎么检测一个线程是否拥有锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#你如何在Java中获取线程堆栈？"><span class="toc-number">5.</span> <span class="toc-text">你如何在Java中获取线程堆栈？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM中哪个参数是用来控制线程的栈堆栈小的"><span class="toc-number">6.</span> <span class="toc-text">JVM中哪个参数是用来控制线程的栈堆栈小的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中synchronized-和-ReentrantLock-有什么不同？"><span class="toc-number">7.</span> <span class="toc-text">Java中synchronized 和 ReentrantLock 有什么不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有三个线程T1，T2，T3，怎么确保它们按顺序执行？"><span class="toc-number">8.</span> <span class="toc-text">有三个线程T1，T2，T3，怎么确保它们按顺序执行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread类中的yield方法有什么作用？"><span class="toc-number">9.</span> <span class="toc-text">Thread类中的yield方法有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中ConcurrentHashMap的并发度是什么？"><span class="toc-number">10.</span> <span class="toc-text">Java中ConcurrentHashMap的并发度是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中Semaphore是什么？"><span class="toc-number">11.</span> <span class="toc-text">Java中Semaphore是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如果你提交任务时，线程池队列已满。会时发会生什么？"><span class="toc-number">12.</span> <span class="toc-text">如果你提交任务时，线程池队列已满。会时发会生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java线程池中submit-和-execute-方法有什么区别？"><span class="toc-number">13.</span> <span class="toc-text">Java线程池中submit() 和 execute()方法有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是阻塞式方法？"><span class="toc-number">14.</span> <span class="toc-text">什么是阻塞式方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swing是线程安全的吗？-为什么？"><span class="toc-number">15.</span> <span class="toc-text">Swing是线程安全的吗？ 为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中invokeAndWait-和-invokeLater有什么区别？"><span class="toc-number">16.</span> <span class="toc-text">Java中invokeAndWait 和 invokeLater有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swing-API中那些方法是线程安全的？"><span class="toc-number">17.</span> <span class="toc-text">Swing API中那些方法是线程安全的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何在Java中创建Immutable对象？"><span class="toc-number">18.</span> <span class="toc-text">如何在Java中创建Immutable对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中的ReadWriteLock是什么？"><span class="toc-number">19.</span> <span class="toc-text">Java中的ReadWriteLock是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程中的忙循环是什么"><span class="toc-number">20.</span> <span class="toc-text">多线程中的忙循环是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile-变量和-atomic-变量有什么不同？"><span class="toc-number">21.</span> <span class="toc-text">volatile 变量和 atomic 变量有什么不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如果同步块内的线程抛出异常会发生什么？"><span class="toc-number">22.</span> <span class="toc-text">如果同步块内的线程抛出异常会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单例模式的双检锁是什么？"><span class="toc-number">23.</span> <span class="toc-text">单例模式的双检锁是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何在Java中创建线程安全的Singleton？"><span class="toc-number">24.</span> <span class="toc-text">如何在Java中创建线程安全的Singleton？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何强制启动一个线程？"><span class="toc-number">25.</span> <span class="toc-text">如何强制启动一个线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中的fork-join框架是什么？"><span class="toc-number">26.</span> <span class="toc-text">Java中的fork join框架是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java多线程中调用wait-和-sleep-方法有什么不同？"><span class="toc-number">27.</span> <span class="toc-text">Java多线程中调用wait() 和 sleep()方法有什么不同？</span></a></li></ol></div></div><div class="post-content"><h3 id="如何写代码来解决生产者消费者问题？"><a href="#如何写代码来解决生产者消费者问题？" class="headerlink" title="如何写代码来解决生产者消费者问题？"></a>如何写代码来解决生产者消费者问题？</h3><p>在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用wait和notify来解决这个问题，比较赞的办法是用Semaphore 或者 BlockingQueue来实现生产者消费者模型。</p>
<h3 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h3><p>Java多线程中的死锁<br>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：</p>
<ul>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li><p>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。<br>避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。</p>
<h3 id="Java中活锁和死锁有什么区别？"><a href="#Java中活锁和死锁有什么区别？" class="headerlink" title="Java中活锁和死锁有什么区别？"></a>Java中活锁和死锁有什么区别？</h3><p>这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。</p>
<h3 id="怎么检测一个线程是否拥有锁？"><a href="#怎么检测一个线程是否拥有锁？" class="headerlink" title="怎么检测一个线程是否拥有锁？"></a>怎么检测一个线程是否拥有锁？</h3><p>我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p>
<h3 id="你如何在Java中获取线程堆栈？"><a href="#你如何在Java中获取线程堆栈？" class="headerlink" title="你如何在Java中获取线程堆栈？"></a>你如何在Java中获取线程堆栈？</h3><p>对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id。</p>
<h3 id="JVM中哪个参数是用来控制线程的栈堆栈小的"><a href="#JVM中哪个参数是用来控制线程的栈堆栈小的" class="headerlink" title="JVM中哪个参数是用来控制线程的栈堆栈小的"></a>JVM中哪个参数是用来控制线程的栈堆栈小的</h3><p>这个问题很简单， -Xss参数用来控制线程的堆栈大小。你可以查看JVM配置列表来了解这个参数的更多信息。</p>
<h3 id="Java中synchronized-和-ReentrantLock-有什么不同？"><a href="#Java中synchronized-和-ReentrantLock-有什么不同？" class="headerlink" title="Java中synchronized 和 ReentrantLock 有什么不同？"></a>Java中synchronized 和 ReentrantLock 有什么不同？</h3><p>Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。</p>
<h3 id="有三个线程T1，T2，T3，怎么确保它们按顺序执行？"><a href="#有三个线程T1，T2，T3，怎么确保它们按顺序执行？" class="headerlink" title="有三个线程T1，T2，T3，怎么确保它们按顺序执行？"></a>有三个线程T1，T2，T3，怎么确保它们按顺序执行？</h3><p>在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。</p>
<h3 id="Thread类中的yield方法有什么作用？"><a href="#Thread类中的yield方法有什么作用？" class="headerlink" title="Thread类中的yield方法有什么作用？"></a>Thread类中的yield方法有什么作用？</h3><p>Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。</p>
<h3 id="Java中ConcurrentHashMap的并发度是什么？"><a href="#Java中ConcurrentHashMap的并发度是什么？" class="headerlink" title="Java中ConcurrentHashMap的并发度是什么？"></a>Java中ConcurrentHashMap的并发度是什么？</h3><p>ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。欲了解更多并发度和内部大小调整请阅读我的文章<a href="https://javarevisited.blogspot.hk/2013/02/concurrenthashmap-in-java-example-tutorial-working.html" target="_blank" rel="noopener">How ConcurrentHashMap works in Java</a>。</p>
<h3 id="Java中Semaphore是什么？"><a href="#Java中Semaphore是什么？" class="headerlink" title="Java中Semaphore是什么？"></a>Java中Semaphore是什么？</h3><p>Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。</p>
<h3 id="如果你提交任务时，线程池队列已满。会时发会生什么？"><a href="#如果你提交任务时，线程池队列已满。会时发会生什么？" class="headerlink" title="如果你提交任务时，线程池队列已满。会时发会生什么？"></a>如果你提交任务时，线程池队列已满。会时发会生什么？</h3><p>这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit()方法将会抛出一个RejectedExecutionException异常。</p>
<h3 id="Java线程池中submit-和-execute-方法有什么区别？"><a href="#Java线程池中submit-和-execute-方法有什么区别？" class="headerlink" title="Java线程池中submit() 和 execute()方法有什么区别？"></a>Java线程池中submit() 和 execute()方法有什么区别？</h3><p>两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。</p>
<h3 id="什么是阻塞式方法？"><a href="#什么是阻塞式方法？" class="headerlink" title="什么是阻塞式方法？"></a>什么是阻塞式方法？</h3><p>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。</p>
<h3 id="Swing是线程安全的吗？-为什么？"><a href="#Swing是线程安全的吗？-为什么？" class="headerlink" title="Swing是线程安全的吗？ 为什么？"></a>Swing是线程安全的吗？ 为什么？</h3><p>你可以很肯定的给出回答，Swing不是线程安全的，但是你应该解释这么回答的原因即便面试官没有问你为什么。当我们说swing不是线程安全的常常提到它的组件，这些组件不能在多线程中进行修改，所有对GUI组件的更新都要在AWT线程中完成，而Swing提供了同步和异步两种回调方法来进行更新。</p>
<h3 id="Java中invokeAndWait-和-invokeLater有什么区别？"><a href="#Java中invokeAndWait-和-invokeLater有什么区别？" class="headerlink" title="Java中invokeAndWait 和 invokeLater有什么区别？"></a>Java中invokeAndWait 和 invokeLater有什么区别？</h3><p>这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。</p>
<h3 id="Swing-API中那些方法是线程安全的？"><a href="#Swing-API中那些方法是线程安全的？" class="headerlink" title="Swing API中那些方法是线程安全的？"></a>Swing API中那些方法是线程安全的？</h3><p>这个问题又提到了swing和线程安全，虽然组件不是线程安全的但是有一些方法是可以被多线程安全调用的，比如repaint(), revalidate()。 JTextComponent的setText()方法和JTextArea的insert() 和 append() 方法也是线程安全的。</p>
<h3 id="如何在Java中创建Immutable对象？"><a href="#如何在Java中创建Immutable对象？" class="headerlink" title="如何在Java中创建Immutable对象？"></a>如何在Java中创建Immutable对象？</h3><p>这个问题看起来和多线程没什么关系， 但不变性有助于简化已经很复杂的并发程序。Immutable对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是Java没有@Immutable这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供setter方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。</p>
<h3 id="Java中的ReadWriteLock是什么？"><a href="#Java中的ReadWriteLock是什么？" class="headerlink" title="Java中的ReadWriteLock是什么？"></a>Java中的ReadWriteLock是什么？</h3><p>一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java中的ReadWriteLock是Java 5 中新增的一个接口，一个ReadWriteLock维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读锁。</p>
<h3 id="多线程中的忙循环是什么"><a href="#多线程中的忙循环是什么" class="headerlink" title="多线程中的忙循环是什么?"></a>多线程中的忙循环是什么?</h3><p>忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。</p>
<h3 id="volatile-变量和-atomic-变量有什么不同？"><a href="#volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="volatile 变量和 atomic 变量有什么不同？"></a>volatile 变量和 atomic 变量有什么不同？</h3><p>这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p>
<h3 id="如果同步块内的线程抛出异常会发生什么？"><a href="#如果同步块内的线程抛出异常会发生什么？" class="headerlink" title="如果同步块内的线程抛出异常会发生什么？"></a>如果同步块内的线程抛出异常会发生什么？</h3><p>这个问题坑了很多Java程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在finally block里释放锁实现。</p>
<h3 id="单例模式的双检锁是什么？"><a href="#单例模式的双检锁是什么？" class="headerlink" title="单例模式的双检锁是什么？"></a>单例模式的双检锁是什么？</h3><p>这个问题在Java面试中经常被问到，但是面试官对回答此问题的满意度仅为50%。一半的人写不出双检锁还有一半的人说不出它的隐患和Java1.5是如何对它修正的。它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，但是由于太过于复杂在JDK1.4中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。</p>
<h3 id="如何在Java中创建线程安全的Singleton？"><a href="#如何在Java中创建线程安全的Singleton？" class="headerlink" title="如何在Java中创建线程安全的Singleton？"></a>如何在Java中创建线程安全的Singleton？</h3><p>这是上面那个问题的后续，如果你不喜欢双检锁而面试官问了创建Singleton类的替代方法，你可以利用JVM的类加载和静态变量初始化特征来创建Singleton实例，或者是利用枚举类型来创建Singleton，我很喜欢用这种方法。<br>写出3条你遵循的多线程最佳实践<br>这种问题我最喜欢了，我相信你在写并发代码来提升性能的时候也会遵循某些最佳实践。以下三条最佳实践我觉得大多数Java程序员都应该遵循：</p>
</li>
<li><p>给你的线程起个有意义的名字。<br>这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。</p>
</li>
<li>避免锁定和缩小同步的范围<br>锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。<br>多用同步类少用wait 和 notify<br>首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。</li>
<li>多用并发集合少用同步集合<br>这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。</li>
</ul>
<h3 id="如何强制启动一个线程？"><a href="#如何强制启动一个线程？" class="headerlink" title="如何强制启动一个线程？"></a>如何强制启动一个线程？</h3><p>这个问题就像是如何强制进行Java垃圾回收，目前还没有觉得方法，虽然你可以使用System.gc()来进行垃圾回收，但是不保证能成功。在Java里面没有办法强制启动一个线程，它是被线程调度器控制着且Java没有公布相关的API。</p>
<h3 id="Java中的fork-join框架是什么？"><a href="#Java中的fork-join框架是什么？" class="headerlink" title="Java中的fork join框架是什么？"></a>Java中的fork join框架是什么？</h3><p>fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。</p>
<h3 id="Java多线程中调用wait-和-sleep-方法有什么不同？"><a href="#Java多线程中调用wait-和-sleep-方法有什么不同？" class="headerlink" title="Java多线程中调用wait() 和 sleep()方法有什么不同？"></a>Java多线程中调用wait() 和 sleep()方法有什么不同？</h3><p>Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。</p>
<blockquote>
<p>原文链接：<a href="https://javarevisited.blogspot.sg/2014/07/top-50-java-multithreading-interview-questions-answers.html" target="_blank" rel="noopener">https://javarevisited.blogspot.sg/2014/07/top-50-java-multithreading-interview-questions-answers.html</a> （需要挂代理访问）<br>翻译： ImportNew.com - 李 广</p>
</blockquote>
</div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=/img/WeChatQR.png&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=https://www.paypal.me/TDonate" style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://ahianzhang.com/2017/11/28/java6/" data-id="cjx9ze2ky00j34kunc2c5vr0u" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAAB00lEQVR42u3azYrDMAxF4bz/S6cwq4Fiz7lSLDJwvColdT53IfTj68Lr/lmrz7/X9zOr3fbPtJZcuXLb3Hu7yOv3FH68vUGuXLnzXBK8Vlusnkz33z8jV67cd3LTZIX/Sq5cuf+XS9KXfhokV67c93BJ8bP/fh/aeGL0WK0mV67cBrffMO1/Hu3vypUrtzGV4AElTYDu0pIrV+4MlyQfhMVbJGmqdJF6SK5cuYe55GcESsqhNCzKlSt3hkvSjv6QNQ2Cy/3lypU7wq0NOU4XOUHDVK5cuYe5vJWZFjlpzxO9S65cuce4vGgJ2hbhxQ5Un6U1lly5chtcHshIOcTbIrxtKleu3HkuT0HSi1xpeEKHlytX7gi3U95wEN+tVozJlSv3WW6t/ZEOU/sFlVy5cie5tZQFjT/DSxjBXyBXrtzDXN7sQJ2VMH2JL3PIlSt3kNt5WecaBz+wXLly57npBSkentJCKLDLlSv3GLeTrKTtktpYtxgE5cqV2+bWgldtiMID2XJnuXLlDnJr7U4+JuERFE2A5cqV+xruPgCl4a/YfJErV+6LuTz1SY/3x2HkypU7yK1tzROjNOl5oC0iV67cBjdtmPJLG2Qoy5MnuXLljnA/tSxN1AntiHoAAAAASUVORK5CYII=" class="article-share-link">分享</a><div class="tags"><a href="/tags/java/">java</a></div><div class="post-nav"><a href="/2017/11/29/life7/" class="pre">个人发展方向问题</a><a href="/2017/11/28/java5/" class="next">50道Java线程问题(上)</a></div><div id="SOHUCS" sid="1511855802000"></div><script>(function(){var appid='cythwr0CO';var conf='prod_808607ebc11359b8ab469bd03b597959';var width=window.innerWidth||document.documentElement.clientWidth;if(width<960){window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id='+appid+'&conf='+conf+'"><\/script>')}else{var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})})}})()
</script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Spring系列/">Spring系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/云计算/">云计算</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/人工智能/">人工智能</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/区块链/">区块链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/微服务/">微服务</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能调优/">性能调优</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/总结/">总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/搜索/">搜索</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数学/">数学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构和算法/">数据结构和算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈/">杂谈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构/">架构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/版本控制/">版本控制</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/环境搭建/">环境搭建</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言学习/">语言学习</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/netty/" style="font-size: 15px;">netty</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/OOP/" style="font-size: 15px;">OOP</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/hdfs/" style="font-size: 15px;">hdfs</a> <a href="/tags/网站/" style="font-size: 15px;">网站</a> <a href="/tags/eos/" style="font-size: 15px;">eos</a> <a href="/tags/指针/" style="font-size: 15px;">指针</a> <a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/CSS3/" style="font-size: 15px;">CSS3</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/英语/" style="font-size: 15px;">英语</a> <a href="/tags/关于博客/" style="font-size: 15px;">关于博客</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/jquery/" style="font-size: 15px;">jquery</a> <a href="/tags/LeetCode/" style="font-size: 15px;">LeetCode</a> <a href="/tags/闲扯/" style="font-size: 15px;">闲扯</a> <a href="/tags/节日/" style="font-size: 15px;">节日</a> <a href="/tags/总结/" style="font-size: 15px;">总结</a> <a href="/tags/故事/" style="font-size: 15px;">故事</a> <a href="/tags/概率论/" style="font-size: 15px;">概率论</a> <a href="/tags/微服务/" style="font-size: 15px;">微服务</a> <a href="/tags/ElasticSearch/" style="font-size: 15px;">ElasticSearch</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/mongodb/" style="font-size: 15px;">mongodb</a> <a href="/tags/os/" style="font-size: 15px;">os</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/性能调优/" style="font-size: 15px;">性能调优</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/OpenCV/" style="font-size: 15px;">OpenCV</a> <a href="/tags/一句话/" style="font-size: 15px;">一句话</a> <a href="/tags/shiro/" style="font-size: 15px;">shiro</a> <a href="/tags/理论/" style="font-size: 15px;">理论</a> <a href="/tags/SpringData/" style="font-size: 15px;">SpringData</a> <a href="/tags/SpringCloud/" style="font-size: 15px;">SpringCloud</a> <a href="/tags/SpringSecurity/" style="font-size: 15px;">SpringSecurity</a> <a href="/tags/年终总结/" style="font-size: 15px;">年终总结</a> <a href="/tags/建站记录/" style="font-size: 15px;">建站记录</a> <a href="/tags/项目总结/" style="font-size: 15px;">项目总结</a> <a href="/tags/工作总结/" style="font-size: 15px;">工作总结</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Termux/" style="font-size: 15px;">Termux</a> <a href="/tags/心得/" style="font-size: 15px;">心得</a> <a href="/tags/nat/" style="font-size: 15px;">nat</a> <a href="/tags/技术/" style="font-size: 15px;">技术</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/wordPress/" style="font-size: 15px;">wordPress</a> <a href="/tags/微信小程序/" style="font-size: 15px;">微信小程序</a> <a href="/tags/法律/" style="font-size: 15px;">法律</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/24/life12/">conviva（北京） 之旅</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/19/code-style-check-ali-p3c/">gitlab 添加代码规范检测</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/18/query-rewrite/">query 改写</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/18/summary10/">阶段性总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/01/os1/">操作系统作用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/30/leetcode206/">leetcode206</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/28/leetcode461/">hamming-distance</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/27/elasticsearch03/">ElasticSearch API 基本操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/24/elasticsearch02/">elasticsearch 集群容错</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/ElasticSearch01/">ElasticSearch 基础概念</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://hacpai.com/" title="黑客派" target="_blank">黑客派</a><ul></ul><a href="https://www.coolshell.cn/" title="酷壳" target="_blank">酷壳</a><ul></ul><a href="http://www.hankcs.com/" title="hankcs" target="_blank">hankcs</a><ul></ul><a href="https://laod.cn/" title="老D博客" target="_blank">老D博客</a><ul></ul><a href="https://www.wrbug.com" title="慢啄" target="_blank">慢啄</a><ul></ul><a href="http://www.imsxm.com/" title="成都没有派对" target="_blank">成都没有派对</a><ul></ul><a href="https://tcxx.info/" title="甜欣屋" target="_blank">甜欣屋</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">象帝浮华生.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?6d760d826594895392280c40a0cdd834";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>